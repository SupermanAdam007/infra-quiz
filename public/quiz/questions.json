{
  "questions": [
    {
      "question": "What is the correct way to define a variable in Terraform?",
      "options": [
        {
          "text": "Using the 'variable' block",
          "snippet": "variable \"instance_type\" {\n  type    = string\n  default = \"t2.micro\"\n}",
          "correct": true,
          "explanation": "This is the correct way to define a variable in Terraform. The 'variable' block allows you to specify the type and optionally provide a default value."
        },
        {
          "text": "Using a simple assignment",
          "snippet": "instance_type = \"t2.micro\"",
          "correct": false,
          "explanation": "This is incorrect. Simple assignments are used for local values, not for defining variables."
        },
        {
          "text": "Using the 'var' keyword",
          "snippet": "var instance_type = \"t2.micro\"",
          "correct": false,
          "explanation": "This is incorrect. The 'var' keyword is used to reference variables, not to define them."
        }
      ]
    },
    {
      "question": "How do you reference a variable in a Terraform configuration?",
      "options": [
        {
          "text": "Using var.variable_name",
          "snippet": "resource \"aws_instance\" \"example\" {\n  instance_type = var.instance_type\n}",
          "correct": true,
          "explanation": "This is correct. Variables are referenced using the 'var.' prefix followed by the variable name."
        },
        {
          "text": "Using ${variable_name}",
          "snippet": "resource \"aws_instance\" \"example\" {\n  instance_type = ${instance_type}\n}",
          "correct": false,
          "explanation": "This is incorrect. This syntax is not valid in Terraform."
        },
        {
          "text": "Using variable.name",
          "snippet": "resource \"aws_instance\" \"example\" {\n  instance_type = variable.instance_type\n}",
          "correct": false,
          "explanation": "This is incorrect. 'variable.' is not the correct prefix for referencing variables."
        }
      ]
    },
    {
      "question": "Explain what a Terraform provider is and how you configure it for AWS.",
      "options": [
        {
          "text": "A plugin that manages remote state storage in AWS S3 and handles variable management. Can be used to manage multiple regions.",
          "snippet": "",
          "correct": false,
          "explanation": "Incorrect – This confuses providers with state backends."
        },
        {
          "text": "A plugin that enables interaction with AWS services via their APIs, configured with region and credentials.",
          "snippet": "",
          "correct": true,
          "explanation": "Correct – This accurately describes a provider's core function."
        },
        {
          "text": "A separate CLI tool for deploying AWS resources independently of Terraform.",
          "snippet": "",
          "correct": false,
          "explanation": "Incorrect – This mischaracterizes how providers work."
        }
      ]
    },
    {
      "question": "Given this EC2 instance configuration, how would you make it terraform workspace-safe when both workspaces are in the same AWS account?",
      "snippet": "resource \"aws_instance\" \"web\" {\n  ami           = \"ami-123456\"\n  instance_type = \"t2.micro\"\n  tags = {\n    Name = \"web-server\"\n  }\n}",
      "options": [
        {
          "text": "Add workspace name to resource names and tags to prevent conflicts between workspaces",
          "snippet": "resource \"aws_instance\" \"web\" {\n  ami           = \"ami-123456\"\n  instance_type = \"t2.micro\"\n  tags = {\n    Name = \"${terraform.workspace}-web-server\"\n  }\n}",
          "correct": true,
          "explanation": "Correct - This ensures unique resource names across workspaces while keeping the configuration DRY"
        },
        {
          "text": "Create separate configuration files for each workspace",
          "snippet": "# dev/main.tf\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-123456\"\n  instance_type = \"t2.micro\"\n  tags = {\n    Name = \"dev-web-server\"\n  }\n}\n\n# prod/main.tf\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-123456\"\n  instance_type = \"t2.micro\"\n  tags = {\n    Name = \"prod-web-server\"\n  }\n}",
          "correct": false,
          "explanation": "Incorrect - This leads to code duplication and maintenance overhead"
        },
        {
          "text": "Use count and conditionals to create resources only in specific workspaces, with complex workspace-specific logic to handle resource naming, tagging, and other configurations that need to be unique per workspace while maintaining the ability to share common configurations across workspaces when needed",
          "snippet": "resource \"aws_instance\" \"web\" {\n  count = terraform.workspace = \"prod\" ? 1 : 0\n  ami           = \"ami-123456\"\n  instance_type = terraform.workspace == \"prod\" ? \"t2.medium\" : \"t2.micro\"\n  tags = {\n    Name = terraform.workspace == \"prod\" ? \"production-web-server\" : \"dev-web-server\"\n    Environment = upper(terraform.workspace)\n    ManagedBy = \"terraform-${terraform.workspace}\"\n  }\n  lifecycle {\n    create_before_destroy = terraform.workspace == \"prod\" ? true : false\n  }\n}",
          "correct": false,
          "explanation": "Incorrect - Contains a syntax error in the count expression that would cause the configuration to fail"
        }
      ]
    },
    {
      "question": "Exercise 2 (Part A): How does using `count` affect resource creation?",
      "options": [
        {
          "text": "Creates configuration copies without actual resource instances.",
          "snippet": "",
          "correct": false,
          "explanation": "Incorrect – It does create the specified number of instances."
        },
        {
          "text": "Creates multiple resource instances based on count value.",
          "snippet": "",
          "correct": true,
          "explanation": "Correct – This accurately describes count's function."
        },
        {
          "text": "Always creates one resource regardless of count value.",
          "snippet": "",
          "correct": false,
          "explanation": "Incorrect – That contradicts the purpose of count."
        }
      ]
    },
    {
      "question": "Exercise 4 (Part A): Explain what the following Terraform code does.",
      "snippet": "resource \"aws_security_group\" \"app_sg\" {\n  name        = \"app_sg\"\n  description = \"Security group for the application\"\n\n  dynamic \"ingress\" {\n    for_each = var.ingress_rules\n    content {\n      from_port   = ingress.value.from_port\n      to_port     = ingress.value.to_port\n      protocol    = ingress.value.protocol\n      cidr_blocks = ingress.value.cidr_blocks\n    }\n  }\n}",
      "options": [
        {
          "text": "It statically defines a single ingress rule and ignores the `var.ingress_rules` variable.",
          "snippet": "",
          "correct": false,
          "explanation": "Incorrect – The use of dynamic indicates multiple rules are intended."
        },
        {
          "text": "It uses a loop to create multiple security groups—one for each item in `var.ingress_rules`.",
          "snippet": "",
          "correct": false,
          "explanation": "Incorrect – It creates multiple ingress rules, not security groups."
        },
        {
          "text": "It dynamically creates multiple ingress rules for the security group based on the items provided in `var.ingress_rules`.",
          "snippet": "",
          "correct": true,
          "explanation": ""
        }
      ]
    },
    {
      "question": "Exercise 4 (Part B): What would be the content of `var.ingress_rules`? Provide an example.",
      "options": [
        {
          "text": "An example value would be:",
          "snippet": "ingress_rules = [\n  { from_port = 80, to_port = 80, protocol = \"tcp\", cidr_blocks = [\"0.0.0.0/0\"] },\n  { from_port = 443, to_port = 443, protocol = \"tcp\", cidr_blocks = [\"0.0.0.0/0\"] }\n]",
          "correct": true,
          "explanation": ""
        },
        {
          "text": "An example value would be:",
          "snippet": "ingress_rules = {\n  port = 80,\n  protocol = \"tcp\"\n}",
          "correct": false,
          "explanation": "Incorrect – The structure does not match the expected list of objects."
        },
        {
          "text": "An example value would be:",
          "snippet": "ingress_rules = \"80,443\"",
          "correct": false,
          "explanation": "Incorrect – A string does not provide the necessary details."
        }
      ]
    },
    {
      "question": "Exercise 5: Review this backend configuration snippet. What additional settings might you add for robust state management?",
      "snippet": "terraform {\n  backend \"s3\" {\n    bucket = \"my-terraform-state\"\n    key    = \"state.tfstate\"\n    region = \"us-west-2\"\n  }\n}",
      "options": [
        {
          "text": "No changes are needed; this basic configuration is sufficient for all team scenarios.",
          "snippet": "",
          "correct": false,
          "explanation": "Incorrect – For team use, additional measures are advisable."
        },
        {
          "text": "Enhance the configuration by adding a DynamoDB table for state locking, enabling encryption on the S3 bucket, and turning on versioning to ensure robust backup and conflict prevention.",
          "snippet": "",
          "correct": true,
          "explanation": ""
        },
        {
          "text": "Simply adjust the region and key values to better organize your state files, leaving locking and encryption to be managed manually.",
          "snippet": "",
          "correct": false,
          "explanation": "Incorrect – This does not address state locking or security best practices."
        }
      ]
    },
    {
      "question": "Exercise 6: Provide an example of how you would parameterize an Auto Scaling group in Terraform to optimize costs during low traffic periods. Outline key variables and configuration blocks you'd consider.",
      "options": [
        {
          "text": "Set fixed capacity values with no scaling policies. While simple, this approach doesn't adjust to traffic fluctuations and isn't cost-effective.",
          "snippet": "",
          "correct": false,
          "explanation": "Incorrect – It fails to optimize costs during low traffic."
        },
        {
          "text": "Remove the Auto Scaling group entirely and rely on a single on-demand instance, as scaling adds unnecessary complexity.",
          "snippet": "",
          "correct": false,
          "explanation": "Incorrect – This sacrifices availability and cost optimization."
        },
        {
          "text": "Define variables such as `desired_capacity`, `min_size`, and `max_size`, and configure scheduled scaling policies that lower the desired capacity during off-peak hours while scaling up during high-demand periods. This dynamic approach ensures efficient resource usage and cost optimization.",
          "snippet": "",
          "correct": true,
          "explanation": ""
        }
      ]
    },
    {
      "question": "Exercise 7: Given the error snippet below, what steps would you take to diagnose and resolve the issue?",
      "snippet": "Error launching source instance: UnauthorizedOperation: You are not authorized to perform this operation.",
      "options": [
        {
          "text": "Restart the AWS instance and try running Terraform again, hoping the issue resolves itself.",
          "snippet": "",
          "correct": false,
          "explanation": "Incorrect – This bypasses proper diagnosis."
        },
        {
          "text": "Disable error checking in Terraform to bypass the error message and force deployment.",
          "snippet": "",
          "correct": false,
          "explanation": "Incorrect – This is unsafe and does not resolve the underlying issue."
        },
        {
          "text": "Review the error details to verify that the AWS credentials used by Terraform have the correct IAM permissions. Check the attached policies and adjust them to grant the necessary actions.",
          "snippet": "",
          "correct": true,
          "explanation": ""
        }
      ]
    },
    {
      "question": "ECS Service Configuration: You need to create an ECS service that runs on Fargate. The service must be attached to an existing ECS cluster and use a given task definition. It also requires the proper network configuration (i.e., subnets, security groups, and public IP assignment). Which snippet is correct?",
      "options": [
        {
          "text": "",
          "snippet": "resource \"aws_ecs_service\" \"service\" {\n  name            = \"my-ecs-service\"\n  cluster         = aws_ecs_cluster.cluster.id\n  task_definition = aws_ecs_task_definition.task.arn\n  desired_count   = 2\n  launch_type     = \"FARGATE\"\n\n  network_configuration {\n    subnets         = var.subnets\n    security_groups = var.security_groups\n    assign_public_ip = true\n  }\n}",
          "correct": true,
          "explanation": "This snippet correctly references the ECS cluster's ID and the task definition's ARN, sets the launch type to FARGATE, and includes a complete network configuration block."
        },
        {
          "text": "",
          "snippet": "resource \"aws_ecs_service\" \"service\" {\n  name            = \"my-ecs-service\"\n  cluster         = aws_ecs_cluster.cluster.name\n  task_definition = aws_ecs_task_definition.task.id\n  desired_count   = 2\n  launch_type     = \"FARGATE\"\n}",
          "correct": false,
          "explanation": "Incorrect – References the cluster by name instead of ID, uses the task definition's ID rather than its ARN, and omits the required network configuration."
        },
        {
          "text": "",
          "snippet": "resource \"aws_ecs_service\" \"service\" {\n  name            = \"my-ecs-service\"\n  cluster         = aws_ecs_cluster.cluster.id\n  task_definition = aws_ecs_task_definition.task.arn\n  desired_count   = 2\n  launch_type     = \"EC2\"\n\n  network_configuration {\n    subnets         = var.subnets\n    security_groups = var.security_groups\n    assign_public_ip = false\n  }\n}",
          "correct": false,
          "explanation": "Incorrect – Uses the EC2 launch type instead of FARGATE and sets assign_public_ip to false."
        }
      ]
    },
    {
      "question": "ECS Task Definition for a Fargate Container: You need to define an ECS task definition for a containerized application to run on Fargate. The task must specify a container definition with an image, CPU, memory settings, and a port mapping. Which snippet is correct?",
      "options": [
        {
          "text": "",
          "snippet": "resource \"aws_ecs_task_definition\" \"task\" {\n  family                   = \"my-task\"\n  network_mode             = \"awsvpc\"\n  requires_compatibilities = [\"FARGATE\"]\n  cpu                      = \"256\"\n  memory                   = \"512\"\n\n  container_definitions = jsonencode([\n    {\n      name      = \"app\"\n      image     = var.image\n      cpu       = 256\n      memory    = 512\n      essential = true\n      portMappings = [\n        {\n          containerPort = 80,\n          hostPort      = 80,\n          protocol      = \"tcp\"\n        }\n      ]\n    }\n  ])\n}",
          "correct": true,
          "explanation": "This snippet correctly uses awsvpc network mode with FARGATE compatibility, and aligns the CPU/memory settings and port mapping."
        },
        {
          "text": "",
          "snippet": "resource \"aws_ecs_task_definition\" \"task\" {\n  family                   = \"my-task\"\n  network_mode             = \"bridge\"\n  requires_compatibilities = [\"EC2\"]\n  cpu                      = \"256\"\n  memory                   = \"512\"\n\n  container_definitions = jsonencode([\n    {\n      name      = \"app\"\n      image     = var.image\n      portMappings = [\n        {\n          containerPort = 80,\n          protocol      = \"tcp\"\n        }\n      ]\n    }\n  ])\n}",
          "correct": false,
          "explanation": "Incorrect – Uses bridge network mode and is configured for EC2 instead of Fargate."
        },
        {
          "text": "",
          "snippet": "resource \"aws_ecs_task_definition\" \"task\" {\n  family                   = \"my-task\"\n  network_mode             = \"awsvpc\"\n  requires_compatibilities = [\"FARGATE\"]\n  cpu                      = \"512\"\n  memory                   = \"1024\"\n\n  container_definitions = jsonencode([\n    {\n      name      = \"app\"\n      image     = var.image\n      cpu       = 256\n      memoryReservation = 512\n      essential = true\n      portMappings = [\n        {\n          containerPort = 8080,\n          hostPort      = 8080,\n          protocol      = \"tcp\"\n        }\n      ]\n    }\n  ])\n}",
          "correct": false,
          "explanation": "Incorrect – Inconsistent CPU/memory values and an unexpected port mapping."
        }
      ]
    },
    {
      "question": "VPC with Public/Private Subnets and NAT Gateway: You need to create a VPC that includes both a public subnet (with an Internet Gateway) and a private subnet (routed through a NAT Gateway). Which Terraform configuration snippet is correct?",
      "options": [
        {
          "text": "",
          "snippet": "resource \"aws_vpc\" \"main\" {\n  cidr_block = \"10.0.0.0/16\"\n}\n\nresource \"aws_internet_gateway\" \"igw\" {\n  vpc_id = aws_vpc.main.id\n}\n\nresource \"aws_subnet\" \"public\" {\n  vpc_id                  = aws_vpc.main.id\n  cidr_block              = \"10.0.1.0/24\"\n  map_public_ip_on_launch = true\n}\n\nresource \"aws_subnet\" \"private\" {\n  vpc_id     = aws_vpc.main.id\n  cidr_block = \"10.0.2.0/24\"\n}\n\nresource \"aws_eip\" \"nat\" {\n  vpc = true\n}\n\nresource \"aws_nat_gateway\" \"nat\" {\n  allocation_id = aws_eip.nat.id\n  subnet_id     = aws_subnet.public.id\n}\n\nresource \"aws_route_table\" \"public_rt\" {\n  vpc_id = aws_vpc.main.id\n\n  route {\n    cidr_block = \"0.0.0.0/0\"\n    gateway_id = aws_internet_gateway.igw.id\n  }\n}\n\nresource \"aws_route_table_association\" \"public_assoc\" {\n  subnet_id      = aws_subnet.public.id\n  route_table_id = aws_route_table.public_rt.id\n}\n\nresource \"aws_route_table\" \"private_rt\" {\n  vpc_id = aws_vpc.main.id\n\n  route {\n    cidr_block    = \"0.0.0.0/0\"\n    nat_gateway_id = aws_nat_gateway.nat.id\n  }\n}\n\nresource \"aws_route_table_association\" \"private_assoc\" {\n  subnet_id      = aws_subnet.private.id\n  route_table_id = aws_route_table.private_rt.id\n}",
          "correct": true,
          "explanation": "This snippet creates a VPC with an Internet Gateway, a public subnet (with automatic public IP assignment), a private subnet, and correct route table associations for both subnets."
        },
        {
          "text": "",
          "snippet": "resource \"aws_vpc\" \"main\" {\n  cidr_block = \"10.0.0.0/16\"\n}\n\nresource \"aws_internet_gateway\" \"igw\" {\n  vpc_id = aws_vpc.main.id\n}\n\nresource \"aws_subnet\" \"public\" {\n  vpc_id     = aws_vpc.main.id\n  cidr_block = \"10.0.1.0/24\"\n}\n\nresource \"aws_subnet\" \"private\" {\n  vpc_id     = aws_vpc.main.id\n  cidr_block = \"10.0.2.0/24\"\n}\n\nresource \"aws_eip\" \"nat\" {\n  vpc = true\n}\n\nresource \"aws_nat_gateway\" \"nat\" {\n  allocation_id = aws_eip.nat.id\n  subnet_id     = aws_subnet.private.id\n}\n\nresource \"aws_route_table\" \"public_rt\" {\n  vpc_id = aws_vpc.main.id\n\n  route {\n    cidr_block    = \"0.0.0.0/0\"\n    nat_gateway_id = aws_nat_gateway.nat.id\n  }\n}\n\nresource \"aws_route_table_association\" \"public_assoc\" {\n  subnet_id      = aws_subnet.public.id\n  route_table_id = aws_route_table.public_rt.id\n}",
          "correct": false,
          "explanation": "Incorrect – The NAT Gateway is assigned to the private subnet and used in the public route table, causing misrouted traffic."
        },
        {
          "text": "",
          "snippet": "resource \"aws_vpc\" \"main\" {\n  cidr_block = \"10.0.0.0/16\"\n}\n\nresource \"aws_internet_gateway\" \"igw\" {\n  vpc_id = aws_vpc.main.id\n}\n\nresource \"aws_subnet\" \"public\" {\n  vpc_id                  = aws_vpc.main.id\n  cidr_block              = \"10.0.1.0/24\"\n  map_public_ip_on_launch = true\n}\n\nresource \"aws_subnet\" \"private\" {\n  vpc_id     = aws_vpc.main.id\n  cidr_block = \"10.0.2.0/24\"\n}\n\nresource \"aws_eip\" \"nat\" {\n  vpc = true\n}\n\nresource \"aws_nat_gateway\" \"nat\" {\n  allocation_id = aws_eip.nat.id\n  subnet_id     = aws_subnet.public.id\n}\n\nresource \"aws_route_table\" \"public_rt\" {\n  vpc_id = aws_vpc.main.id\n\n  route {\n    cidr_block = \"0.0.0.0/0\"\n    gateway_id = aws_internet_gateway.igw.id\n  }\n}\n\nresource \"aws_route_table_association\" \"public_assoc\" {\n  subnet_id      = aws_subnet.public.id\n  route_table_id = aws_route_table.public_rt.id\n}",
          "correct": false,
          "explanation": "Incorrect – Omits the private subnet's route table and association, leaving it without proper Internet access via the NAT Gateway."
        }
      ]
    },
    {
      "question": "Security Group for a Web Application: You need to create a security group that allows inbound HTTP (port 80) and HTTPS (port 443) traffic from anywhere, and permits all outbound traffic. Which Terraform configuration snippet is correct?",
      "options": [
        {
          "text": "",
          "snippet": "resource \"aws_security_group\" \"web_sg\" {\n  name        = \"web_sg\"\n  description = \"Allow HTTP and HTTPS inbound\"\n  vpc_id      = var.vpc_id\n\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  ingress {\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  egress {\n    from_port   = 0,\n    to_port     = 0,\n    protocol    = \"-1\",\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}",
          "correct": true,
          "explanation": "This snippet defines two distinct ingress rules for HTTP and HTTPS and includes an explicit egress rule that allows all outbound traffic."
        },
        {
          "text": "",
          "snippet": "resource \"aws_security_group\" \"web_sg\" {\n  name        = \"web_sg\"\n  description = \"Allow HTTP and HTTPS inbound\"\n  vpc_id      = var.vpc_id\n\n  ingress {\n    from_port   = 80,\n    to_port     = 443,\n    protocol    = \"tcp\",\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  egress {\n    from_port   = 0,\n    to_port     = 0,\n    protocol    = \"tcp\",\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}",
          "correct": false,
          "explanation": "Incorrect – Merges ports 80 and 443 into one ingress rule and restricts egress to TCP only."
        },
        {
          "text": "",
          "snippet": "resource \"aws_security_group\" \"web_sg\" {\n  name        = \"web_sg\"\n  description = \"Allow HTTP and HTTPS inbound\"\n  vpc_id      = var.vpc_id\n\n  ingress {\n    from_port   = 80,\n    to_port     = 80,\n    protocol    = \"tcp\",\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  ingress {\n    from_port   = 443,\n    to_port     = 443,\n    protocol    = \"tcp\",\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}",
          "correct": false,
          "explanation": "Incorrect – Does not include an explicit egress rule; relying on defaults is not best practice."
        }
      ]
    }
  ]
}
